# -*- coding: utf-8 -*-

import itertools
from kep.parser.containers import get_blocks, get_year
from kep.parser.row_utils.utils import filter_value

def yield_datapoints(row_tuple: list, varname: str, year: int) -> iter:
    """Yield dictionaries containing individual datapoints based on *row_tuple* content.    
    
    :param row_tuple: tuple with annual value and lists of quarterly and monthly values
    :param varname: string like 'GDP_yoy'
    :param year: int
    :return: dictionaries ready to feed into pd.Dataframe
    """
    # a - annual value, just one number
    # qs - quarterly values, list of 4 elements
    # ms - monthly values, list of 12 elements
    a, qs, ms = row_tuple

    # annual value, yield if present
    if a:
        yield {'freq': 'a',
               'varname': varname,
               'year': year,
               'value': filter_value(a)}
    # quarterly values, yield if present
    if qs:
        for i, val in enumerate(qs):
            if val:
                yield {'freq': 'q',
                       'varname': varname,
                       'year': year,
                       'qtr': i + 1,
                       'value': filter_value(val)}
    # quarterly values, yield if present
    if ms:
        for j, val in enumerate(ms):
            if val:
                yield {'freq': 'm',
                       'varname': varname,
                       'year': year,
                       'month': j + 1,
                       'value': filter_value(val)}

               
def datablock_to_stream(label, datarows, splitter_func):
    if label:        
        for row in datarows:
            a, qs, ms = splitter_func(row['data']) 
            for dp in yield_datapoints(row_tuple=(a, qs, ms),
                               year=get_year(row['head']),
                               varname=label):
                yield dp


class Datapoints():
    """Emit a stream datapoints from *csv_dicts* according to *parse_def*."""

    def __init__(self, csv_dicts, parse_def):
        """
        csv_dicts: iterable of dictionaries with csv file content by row
                   each dictionary has 'head', 'data'
                   generated by CSV_Reader(path).yield_dicts()              
        parse_def: object containing header dict, units dict and splitter func name
                   generated by ParsingDefinition(path)
        """
        
        self.blocks = get_blocks(csv_dicts, parse_def)
        self.datapoints = list(self.walk_by_blocks())

    def walk_by_blocks(self):
        for block in self.blocks:
            for datapoint in datablock_to_stream(label=block.label
                                               , datarows=block.datarows
                                               , splitter_func=block.splitter_func):
                yield datapoint                
      
    def emit(self, freq):
        """Returns generator of dictionaries of datapoints as formatted 
           by yield_datapoints().
           
           param freq: 'a', 'q' or 'm' 
        """
        if freq in 'aqm':
            for p in self.datapoints:
                if p['freq'] == freq:
                    # Note: (1) 'freq' key will be redundant for later use in
                    #           dataframe, drop it
                    #       (2) without copy() pop() changes self.datapoints
                    z = p.copy()
                    z.pop('freq')
                    yield z
        else:
            raise ValueError(freq)

    def is_included(self, datapoint):
        """Return True if *datapoint* is in *self.datapoints*"""
        return datapoint in self.datapoints

    
    def hashdict(self):
        return {hash(d):d['value'] for d in self.datapoints}             
        
    def count(self):
        """Diagnostics: count occurrences of unique variales in self.datapoints
                        Better be 1 for all."""
                
        #variables = [drop_value(d) for d in self.datapoints]
        # in dictionary hash will appear only once with correct count
        #y = {hash(x): (variables.count(x), x) for x in variables}
        #return [dict(variable=v[1], count=v[0]) for k,v in y.items()]
        return None
        
    def overcount(self):
        return [d for d in self.count() if d['count']>1 and d['variable']['year'] == 2017]

    def duplicates(self):
        variables = [drop_value(d) for d in self.datapoints]    
        return [hash(x) for x in variables if variables.count(x) > 1]

def hash(d):
    keys = ['freq','varname','year']
    if d['freq'] == 'm': keys.append('month')
    if d['freq'] == 'q': keys.append('qtr')
    return "^".join([str(d[key]) for key in keys])

def drop_value(d):
    """Return same dictionary without 'value' key."""
    return [(k,v) for k,v in d.items() if v!='value'] 
        

if __name__ == "__main__":
    # inputs
    from kep.release import get_csv_dicts, get_pdef
    year = month = 0
    csv_dicts = get_csv_dicts(year, month)
    parse_def = get_pdef()

    # dataset
    d = Datapoints(csv_dicts, parse_def)
    output = list(d.emit('a'))
    
    #assert len(d.duplicates()) == 0
    extrapoint = {'freq': 'a', 'varname': 'GDP_bln_rub', 'year': 1999, 'value': 0}         
    #d.datapoints.append(extrapoint)
    #assert len(d.duplicates()) == 1
    #assert d.duplicates() == [extrapoint]
    
    def yield_duplicates(self):
        unique_datapoints = []
        for p in self.datapoints:
            z = drop_value(p)
            if z not in unique_datapoints:
                unique_datapoints.append(z)
            else:
                yield p 
                
            
    #dups = list(yield_duplicates(d))

    # ERROR:      
    
    z = [x for x in d.emit('m') if x['varname'] == "CPI_rog" and x['year'] == 2016 and x['month'] == 2]
    #[{'month': 2, 'value': 100.6, 'varname': 'CPI_rog', 'year': 2016},
    # {'month': 2, 'value': 100.6, 'varname': 'CPI_rog', 'year': 2016}]        
    
    f = d.hashdict()
    for x in d.hashdict():
        
        


# TODO: need more information displayed about
#    """WARNING: unexpected row with length 3"""